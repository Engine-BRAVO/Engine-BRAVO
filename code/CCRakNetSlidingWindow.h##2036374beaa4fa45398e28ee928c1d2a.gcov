        -:    0:Source:/home/ronan/Documents/2024-2025/Minor/Engine-BRAVO/code/external/SLikeNet/Source/include/slikenet/CCRakNetSlidingWindow.h
        -:    0:Graph:build/external/SLikeNet/Lib/LibStatic/CMakeFiles/RakNetLibStatic.dir/__/__/Source/src/ReliabilityLayer.cpp.gcno
        -:    0:Data:build/external/SLikeNet/Lib/LibStatic/CMakeFiles/RakNetLibStatic.dir/__/__/Source/src/ReliabilityLayer.cpp.gcda
        -:    0:Runs:0
        -:    1:/*
        -:    2: *  Original work: Copyright (c) 2014, Oculus VR, Inc.
        -:    3: *  All rights reserved.
        -:    4: *
        -:    5: *  This source code is licensed under the BSD-style license found in the
        -:    6: *  RakNet License.txt file in the licenses directory of this source tree. An additional grant 
        -:    7: *  of patent rights can be found in the RakNet Patents.txt file in the same directory.
        -:    8: *
        -:    9: *
        -:   10: *  Modified work: Copyright (c) 2017, SLikeSoft UG (haftungsbeschr√§nkt)
        -:   11: *
        -:   12: *  This source code was modified by SLikeSoft. Modifications are licensed under the MIT-style
        -:   13: *  license found in the license.txt file in the root directory of this source tree.
        -:   14: */
        -:   15:
        -:   16:/*
        -:   17:http://www.ssfnet.org/Exchange/tcp/tcpTutorialNotes.html
        -:   18:
        -:   19:cwnd=max bytes allowed on wire at once
        -:   20:
        -:   21:Start:
        -:   22:cwnd=mtu
        -:   23:ssthresh=unlimited
        -:   24:
        -:   25:Slow start:
        -:   26:On ack cwnd*=2
        -:   27:
        -:   28:congestion avoidance:
        -:   29:On ack during new period
        -:   30:cwnd+=mtu*mtu/cwnd
        -:   31:
        -:   32:on loss or duplicate ack during period:
        -:   33:sshtresh=cwnd/2
        -:   34:cwnd=MTU
        -:   35:This reenters slow start
        -:   36:
        -:   37:If cwnd < ssthresh, then use slow start
        -:   38:else use congestion avoidance
        -:   39:
        -:   40:
        -:   41:*/
        -:   42:
        -:   43:#include "defines.h"
        -:   44:
        -:   45:#if USE_SLIDING_WINDOW_CONGESTION_CONTROL==1
        -:   46:
        -:   47:#ifndef __CONGESTION_CONTROL_SLIDING_WINDOW_H
        -:   48:#define __CONGESTION_CONTROL_SLIDING_WINDOW_H
        -:   49:
        -:   50:#include "NativeTypes.h"
        -:   51:#include "time.h"
        -:   52:#include "types.h"
        -:   53:#include "DS_Queue.h"
        -:   54:
        -:   55:/// Sizeof an UDP header in byte
        -:   56:#define UDP_HEADER_SIZE 28
        -:   57:
        -:   58:#define CC_DEBUG_PRINTF_1(x)
        -:   59:#define CC_DEBUG_PRINTF_2(x,y)
        -:   60:#define CC_DEBUG_PRINTF_3(x,y,z)
        -:   61:#define CC_DEBUG_PRINTF_4(x,y,z,a)
        -:   62:#define CC_DEBUG_PRINTF_5(x,y,z,a,b)
        -:   63://#define CC_DEBUG_PRINTF_1(x) printf(x)
        -:   64://#define CC_DEBUG_PRINTF_2(x,y) printf(x,y)
        -:   65://#define CC_DEBUG_PRINTF_3(x,y,z) printf(x,y,z)
        -:   66://#define CC_DEBUG_PRINTF_4(x,y,z,a) printf(x,y,z,a)
        -:   67://#define CC_DEBUG_PRINTF_5(x,y,z,a,b) printf(x,y,z,a,b)
        -:   68:
        -:   69:/// Set to 4 if you are using the iPod Touch TG. See http://www.jenkinssoftware.com/forum/index.php?topic=2717.0
        -:   70:#define CC_TIME_TYPE_BYTES 8
        -:   71:
        -:   72:#if CC_TIME_TYPE_BYTES==8
        -:   73:typedef SLNet::TimeUS CCTimeType;
        -:   74:#else
        -:   75:typedef SLNet::TimeMS CCTimeType;
        -:   76:#endif
        -:   77:
        -:   78:typedef SLNet::uint24_t DatagramSequenceNumberType;
        -:   79:typedef double BytesPerMicrosecond;
        -:   80:typedef double BytesPerSecond;
        -:   81:typedef double MicrosecondsPerByte;
        -:   82:
        -:   83:namespace SLNet
        -:   84:{
        -:   85:
        -:   86:class CCRakNetSlidingWindow
        -:   87:{
        -:   88:	public:
        -:   89:	
        -:   90:	CCRakNetSlidingWindow();
        -:   91:	~CCRakNetSlidingWindow();
        -:   92:
        -:   93:	/// Reset all variables to their initial states, for a new connection
        -:   94:	void Init(CCTimeType curTime, uint32_t maxDatagramPayload);
        -:   95:
        -:   96:	/// Update over time
        -:   97:	void Update(CCTimeType curTime, bool hasDataToSendOrResend);
        -:   98:
        -:   99:	int GetRetransmissionBandwidth(CCTimeType curTime, CCTimeType timeSinceLastTick, uint32_t unacknowledgedBytes, bool isContinuousSend);
        -:  100:	int GetTransmissionBandwidth(CCTimeType curTime, CCTimeType timeSinceLastTick, uint32_t unacknowledgedBytes, bool isContinuousSend);
        -:  101:
        -:  102:	/// Acks do not have to be sent immediately. Instead, they can be buffered up such that groups of acks are sent at a time
        -:  103:	/// This reduces overall bandwidth usage
        -:  104:	/// How long they can be buffered depends on the retransmit time of the sender
        -:  105:	/// Should call once per update tick, and send if needed
        -:  106:	bool ShouldSendACKs(CCTimeType curTime, CCTimeType estimatedTimeToNextTick);
        -:  107:
        -:  108:	/// Every data packet sent must contain a sequence number
        -:  109:	/// Call this function to get it. The sequence number is passed into OnGotPacketPair()
        -:  110:	DatagramSequenceNumberType GetAndIncrementNextDatagramSequenceNumber(void);
        -:  111:	DatagramSequenceNumberType GetNextDatagramSequenceNumber(void);
        -:  112:
        -:  113:	/// Call this when you send packets
        -:  114:	/// Every 15th and 16th packets should be sent as a packet pair if possible
        -:  115:	/// When packets marked as a packet pair arrive, pass to OnGotPacketPair()
        -:  116:	/// When any packets arrive, (additionally) pass to OnGotPacket
        -:  117:	/// Packets should contain our system time, so we can pass rtt to OnNonDuplicateAck()
        -:  118:	void OnSendBytes(CCTimeType curTime, uint32_t numBytes);
        -:  119:
        -:  120:	/// Call this when you get a packet pair
        -:  121:	void OnGotPacketPair(DatagramSequenceNumberType datagramSequenceNumber, uint32_t sizeInBytes, CCTimeType curTime);
        -:  122:
        -:  123:	/// Call this when you get a packet (including packet pairs)
        -:  124:	/// If the DatagramSequenceNumberType is out of order, skippedMessageCount will be non-zero
        -:  125:	/// In that case, send a NAK for every sequence number up to that count
        -:  126:	bool OnGotPacket(DatagramSequenceNumberType datagramSequenceNumber, bool isContinuousSend, CCTimeType curTime, uint32_t sizeInBytes, uint32_t *skippedMessageCount);
        -:  127:
        -:  128:	/// Call when you get a NAK, with the sequence number of the lost message
        -:  129:	/// Affects the congestion control
        -:  130:	void OnResend(CCTimeType curTime, SLNet::TimeUS nextActionTime);
        -:  131:	void OnNAK(CCTimeType curTime, DatagramSequenceNumberType nakSequenceNumber);
        -:  132:
        -:  133:	/// Call this when an ACK arrives.
        -:  134:	/// hasBAndAS are possibly written with the ack, see OnSendAck()
        -:  135:	/// B and AS are used in the calculations in UpdateWindowSizeAndAckOnAckPerSyn
        -:  136:	/// B and AS are updated at most once per SYN 
        -:  137:	void OnAck(CCTimeType curTime, CCTimeType rtt, bool hasBAndAS, BytesPerMicrosecond _B, BytesPerMicrosecond _AS, double totalUserDataBytesAcked, bool isContinuousSend, DatagramSequenceNumberType sequenceNumber );
        -:  138:	void OnDuplicateAck( CCTimeType curTime, DatagramSequenceNumberType sequenceNumber );
        -:  139:	
        -:  140:	/// Call when you send an ack, to see if the ack should have the B and AS parameters transmitted
        -:  141:	/// Call before calling OnSendAck()
        -:  142:	void OnSendAckGetBAndAS(CCTimeType curTime, bool *hasBAndAS, BytesPerMicrosecond *_B, BytesPerMicrosecond *_AS);
        -:  143:
        -:  144:	/// Call when we send an ack, to write B and AS if needed
        -:  145:	/// B and AS are only written once per SYN, to prevent slow calculations
        -:  146:	/// Also updates SND, the period between sends, since data is written out
        -:  147:	/// Be sure to call OnSendAckGetBAndAS() before calling OnSendAck(), since whether you write it or not affects \a numBytes
        -:  148:	void OnSendAck(CCTimeType curTime, uint32_t numBytes);
        -:  149:
        -:  150:	/// Call when we send a NACK
        -:  151:	/// Also updates SND, the period between sends, since data is written out
        -:  152:	void OnSendNACK(CCTimeType curTime, uint32_t numBytes);
        -:  153:	
        -:  154:	/// Retransmission time out for the sender
        -:  155:	/// If the time difference between when a message was last transmitted, and the current time is greater than RTO then packet is eligible for retransmission, pending congestion control
        -:  156:	/// RTO = (RTT + 4 * RTTVar) + SYN
        -:  157:	/// If we have been continuously sending for the last RTO, and no ACK or NAK at all, SND*=2;
        -:  158:	/// This is per message, which is different from UDT, but RakNet supports packetloss with continuing data where UDT is only RELIABLE_ORDERED
        -:  159:	/// Minimum value is 100 milliseconds
        -:  160:	CCTimeType GetRTOForRetransmission(unsigned char timesSent) const;
        -:  161:
        -:  162:	/// Set the maximum amount of data that can be sent in one datagram
        -:  163:	/// Default to MAXIMUM_MTU_SIZE-UDP_HEADER_SIZE
        -:  164:	void SetMTU(uint32_t bytes);
        -:  165:
        -:  166:	/// Return what was set by SetMTU()
        -:  167:	uint32_t GetMTU(void) const;
        -:  168:
        -:  169:	/// Query for statistics
        -:  170:	BytesPerMicrosecond GetLocalSendRate(void) const {return 0;}
        -:  171:	BytesPerMicrosecond GetLocalReceiveRate(CCTimeType currentTime) const;
        -:  172:	BytesPerMicrosecond GetRemoveReceiveRate(void) const {return 0;}
        -:  173:	//BytesPerMicrosecond GetEstimatedBandwidth(void) const {return B;}
        -:  174:	BytesPerMicrosecond GetEstimatedBandwidth(void) const {return GetLinkCapacityBytesPerSecond()*1000000.0;}
        -:  175:	double GetLinkCapacityBytesPerSecond(void) const {return 0;}
        -:  176:
        -:  177:	/// Query for statistics
        -:  178:	double GetRTT(void) const;
        -:  179:
function SLNet::CCRakNetSlidingWindow::GetIsInSlowStart() const called 0 returned 0% blocks executed 0%
    #####:  180:	bool GetIsInSlowStart(void) const {return IsInSlowStart();}
    %%%%%:  180-block  0
call    0 never executed
        -:  181:	uint32_t GetCWNDLimit(void) const {return (uint32_t) 0;}
        -:  182:
        -:  183:
        -:  184:	/// Is a > b, accounting for variable overflow?
        -:  185:	static bool GreaterThan(DatagramSequenceNumberType a, DatagramSequenceNumberType b);
        -:  186:	/// Is a < b, accounting for variable overflow?
        -:  187:	static bool LessThan(DatagramSequenceNumberType a, DatagramSequenceNumberType b);
        -:  188://	void SetTimeBetweenSendsLimit(unsigned int bitsPerSecond);
        -:  189:	uint64_t GetBytesPerSecondLimitByCongestionControl(void) const;
        -:  190:	  
        -:  191:	protected:
        -:  192:
        -:  193:	// Maximum amount of bytes that the user can send, e.g. the size of one full datagram
        -:  194:	uint32_t MAXIMUM_MTU_INCLUDING_UDP_HEADER;
        -:  195:
        -:  196:	double cwnd; // max bytes on wire
        -:  197:	double ssThresh; // Threshhold between slow start and congestion avoidance
        -:  198:
        -:  199:	/// When we get an ack, if oldestUnsentAck==0, set it to the current time
        -:  200:	/// When we send out acks, set oldestUnsentAck to 0
        -:  201:	CCTimeType oldestUnsentAck;
        -:  202:
        -:  203:	CCTimeType GetSenderRTOForACK(void) const;
        -:  204:
        -:  205:	/// Every outgoing datagram is assigned a sequence number, which increments by 1 every assignment
        -:  206:	DatagramSequenceNumberType nextDatagramSequenceNumber;
        -:  207:	DatagramSequenceNumberType nextCongestionControlBlock;
        -:  208:	bool backoffThisBlock, speedUpThisBlock;
        -:  209:	/// Track which datagram sequence numbers have arrived.
        -:  210:	/// If a sequence number is skipped, send a NAK for all skipped messages
        -:  211:	DatagramSequenceNumberType expectedNextSequenceNumber;
        -:  212:
        -:  213:	bool _isContinuousSend;
        -:  214:
        -:  215:	bool IsInSlowStart(void) const;
        -:  216:
        -:  217:	double lastRtt, estimatedRTT, deviationRtt;
        -:  218:
        -:  219:};
        -:  220:
        -:  221:}
        -:  222:
        -:  223:#endif
        -:  224:
        -:  225:#endif
