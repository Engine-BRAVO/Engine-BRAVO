        -:    0:Source:/home/angel/projectMinor/Bullet_Bravo/code/external/Engine-Bravo/code/external/BehaviorTree/include/behaviortree_cpp/blackboard.h
        -:    0:Graph:build/external/BehaviorTree/CMakeFiles/behaviortree_cpp.dir/src/blackboard.cpp.gcno
        -:    0:Data:build/external/BehaviorTree/CMakeFiles/behaviortree_cpp.dir/src/blackboard.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:
        -:    3:#include <string>
        -:    4:#include <memory>
        -:    5:#include <unordered_map>
        -:    6:#include <mutex>
        -:    7:
        -:    8:#include "behaviortree_cpp/basic_types.h"
        -:    9:#include "behaviortree_cpp/contrib/json.hpp"
        -:   10:#include "behaviortree_cpp/utils/safe_any.hpp"
        -:   11:#include "behaviortree_cpp/exceptions.h"
        -:   12:#include "behaviortree_cpp/utils/locked_reference.hpp"
        -:   13:
        -:   14:namespace BT
        -:   15:{
        -:   16:
        -:   17:/// This type contains a pointer to Any, protected
        -:   18:/// with a locked mutex as long as the object is in scope
        -:   19:using AnyPtrLocked = LockedPtr<Any>;
        -:   20:
        -:   21:template <typename T>
        -:   22:struct StampedValue
        -:   23:{
        -:   24:  T value;
        -:   25:  Timestamp stamp;
        -:   26:};
        -:   27:
        -:   28:/**
        -:   29: * @brief The Blackboard is the mechanism used by BehaviorTrees to exchange
        -:   30: * typed data.
        -:   31: */
        -:   32:class Blackboard
        -:   33:{
        -:   34:public:
        -:   35:  using Ptr = std::shared_ptr<Blackboard>;
        -:   36:
        -:   37:protected:
        -:   38:  // This is intentionally protected. Use Blackboard::create instead
        -:   39:  Blackboard(Blackboard::Ptr parent) : parent_bb_(parent)
        -:   40:  {}
        -:   41:
        -:   42:public:
        -:   43:  struct Entry
        -:   44:  {
        -:   45:    Any value;
        -:   46:    TypeInfo info;
        -:   47:    StringConverter string_converter;
        -:   48:    mutable std::mutex entry_mutex;
        -:   49:
        -:   50:    uint64_t sequence_id = 0;
        -:   51:    // timestamp since epoch
    #####:   52:    std::chrono::nanoseconds stamp = std::chrono::nanoseconds{ 0 };
        -:   53:
function BT::Blackboard::Entry::Entry(BT::TypeInfo const&) called 0 returned 0% blocks executed 0%
    #####:   54:    Entry(const TypeInfo& _info) : info(_info)
    %%%%%:   54-block  0
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    %%%%%:   54-block  1
call    4 never executed
call    5 never executed
call    6 never executed
    #####:   55:    {}
    $$$$$:   55-block  0
call    0 never executed
        -:   56:
        -:   57:    Entry& operator=(const Entry& other);
        -:   58:  };
        -:   59:
        -:   60:  /** Use this static method to create an instance of the BlackBoard
        -:   61:    *   to share among all your NodeTrees.
        -:   62:    */
        -:   63:  static Blackboard::Ptr create(Blackboard::Ptr parent = {})
        -:   64:  {
        -:   65:    return std::shared_ptr<Blackboard>(new Blackboard(parent));
        -:   66:  }
        -:   67:
        -:   68:  virtual ~Blackboard() = default;
        -:   69:
        -:   70:  void enableAutoRemapping(bool remapping);
        -:   71:
        -:   72:  [[nodiscard]] const std::shared_ptr<Entry> getEntry(const std::string& key) const;
        -:   73:
        -:   74:  [[nodiscard]] std::shared_ptr<Blackboard::Entry> getEntry(const std::string& key);
        -:   75:
        -:   76:  [[nodiscard]] AnyPtrLocked getAnyLocked(const std::string& key);
        -:   77:
        -:   78:  [[nodiscard]] AnyPtrLocked getAnyLocked(const std::string& key) const;
        -:   79:
        -:   80:  [[deprecated("Use getAnyLocked instead")]] const Any*
        -:   81:  getAny(const std::string& key) const;
        -:   82:
        -:   83:  [[deprecated("Use getAnyLocked instead")]] Any* getAny(const std::string& key);
        -:   84:
        -:   85:  /** Return true if the entry with the given key was found.
        -:   86:   *  Note that this method may throw an exception if the cast to T failed.
        -:   87:   */
        -:   88:  template <typename T>
        -:   89:  [[nodiscard]] bool get(const std::string& key, T& value) const;
        -:   90:
        -:   91:  template <typename T>
        -:   92:  [[nodiscard]] Expected<Timestamp> getStamped(const std::string& key, T& value) const;
        -:   93:
        -:   94:  /**
        -:   95:   * Version of get() that throws if it fails.
        -:   96:   */
        -:   97:  template <typename T>
        -:   98:  [[nodiscard]] T get(const std::string& key) const;
        -:   99:
        -:  100:  template <typename T>
        -:  101:  [[nodiscard]] Expected<StampedValue<T>> getStamped(const std::string& key) const;
        -:  102:
        -:  103:  /// Update the entry with the given key
        -:  104:  template <typename T>
        -:  105:  void set(const std::string& key, const T& value);
        -:  106:
        -:  107:  void unset(const std::string& key);
        -:  108:
        -:  109:  [[nodiscard]] const TypeInfo* entryInfo(const std::string& key);
        -:  110:
        -:  111:  void addSubtreeRemapping(StringView internal, StringView external);
        -:  112:
        -:  113:  void debugMessage() const;
        -:  114:
        -:  115:  [[nodiscard]] std::vector<StringView> getKeys() const;
        -:  116:
        -:  117:  [[deprecated("This command is unsafe. Consider using Backup/Restore instead")]] void
        -:  118:  clear();
        -:  119:
        -:  120:  [[deprecated("Use getAnyLocked to access safely an Entry")]] std::recursive_mutex&
        -:  121:  entryMutex() const;
        -:  122:
        -:  123:  void createEntry(const std::string& key, const TypeInfo& info);
        -:  124:
        -:  125:  /**
        -:  126:   * @brief cloneInto copies the values of the entries
        -:  127:   * into another blackboard.  Known limitations:
        -:  128:   *
        -:  129:   * - it doesn't update the remapping in dst
        -:  130:   * - it doesn't change the parent blackboard os dst
        -:  131:   *
        -:  132:   * @param dst destination, i.e. blackboard to be updated
        -:  133:   */
        -:  134:  void cloneInto(Blackboard& dst) const;
        -:  135:
        -:  136:  Blackboard::Ptr parent();
        -:  137:
        -:  138:  // recursively look for parent Blackboard, until you find the root
        -:  139:  Blackboard* rootBlackboard();
        -:  140:
        -:  141:  const Blackboard* rootBlackboard() const;
        -:  142:
        -:  143:private:
        -:  144:  mutable std::mutex mutex_;
        -:  145:  mutable std::recursive_mutex entry_mutex_;
        -:  146:  std::unordered_map<std::string, std::shared_ptr<Entry>> storage_;
        -:  147:  std::weak_ptr<Blackboard> parent_bb_;
        -:  148:  std::unordered_map<std::string, std::string> internal_to_external_;
        -:  149:
        -:  150:  std::shared_ptr<Entry> createEntryImpl(const std::string& key, const TypeInfo& info);
        -:  151:
        -:  152:  bool autoremapping_ = false;
        -:  153:};
        -:  154:
        -:  155:/**
        -:  156: * @brief ExportBlackboardToJSON will create a JSON
        -:  157: * that contains the current values of the blackboard.
        -:  158: * Complex types must be registered with JsonExporter::get()
        -:  159: */
        -:  160:nlohmann::json ExportBlackboardToJSON(const Blackboard& blackboard);
        -:  161:
        -:  162:/**
        -:  163: * @brief ImportBlackboardFromJSON will append elements to the blackboard,
        -:  164: * using the values parsed from the JSON file created using ExportBlackboardToJSON.
        -:  165: * Complex types must be registered with JsonExporter::get()
        -:  166: */
        -:  167:void ImportBlackboardFromJSON(const nlohmann::json& json, Blackboard& blackboard);
        -:  168:
        -:  169://------------------------------------------------------
        -:  170:
        -:  171:template <typename T>
        -:  172:inline T Blackboard::get(const std::string& key) const
        -:  173:{
        -:  174:  if(auto any_ref = getAnyLocked(key))
        -:  175:  {
        -:  176:    const auto& any = any_ref.get();
        -:  177:    if(any->empty())
        -:  178:    {
        -:  179:      throw RuntimeError("Blackboard::get() error. Entry [", key,
        -:  180:                         "] hasn't been initialized, yet");
        -:  181:    }
        -:  182:    return any_ref.get()->cast<T>();
        -:  183:  }
        -:  184:  throw RuntimeError("Blackboard::get() error. Missing key [", key, "]");
        -:  185:}
        -:  186:
        -:  187:inline void Blackboard::unset(const std::string& key)
        -:  188:{
        -:  189:  std::unique_lock lock(mutex_);
        -:  190:
        -:  191:  // check local storage
        -:  192:  auto it = storage_.find(key);
        -:  193:  if(it == storage_.end())
        -:  194:  {
        -:  195:    // No entry, nothing to do.
        -:  196:    return;
        -:  197:  }
        -:  198:
        -:  199:  storage_.erase(it);
        -:  200:}
        -:  201:
        -:  202:template <typename T>
        -:  203:inline void Blackboard::set(const std::string& key, const T& value)
        -:  204:{
        -:  205:  if(StartWith(key, '@'))
        -:  206:  {
        -:  207:    rootBlackboard()->set(key.substr(1, key.size() - 1), value);
        -:  208:    return;
        -:  209:  }
        -:  210:  std::unique_lock lock(mutex_);
        -:  211:
        -:  212:  // check local storage
        -:  213:  auto it = storage_.find(key);
        -:  214:  if(it == storage_.end())
        -:  215:  {
        -:  216:    // create a new entry
        -:  217:    Any new_value(value);
        -:  218:    lock.unlock();
        -:  219:    std::shared_ptr<Blackboard::Entry> entry;
        -:  220:    // if a new generic port is created with a string, it's type should be AnyTypeAllowed
        -:  221:    if constexpr(std::is_same_v<std::string, T>)
        -:  222:    {
        -:  223:      entry = createEntryImpl(key, PortInfo(PortDirection::INOUT));
        -:  224:    }
        -:  225:    else
        -:  226:    {
        -:  227:      PortInfo new_port(PortDirection::INOUT, new_value.type(),
        -:  228:                        GetAnyFromStringFunctor<T>());
        -:  229:      entry = createEntryImpl(key, new_port);
        -:  230:    }
        -:  231:    lock.lock();
        -:  232:
        -:  233:    entry->value = new_value;
        -:  234:    entry->sequence_id++;
        -:  235:    entry->stamp = std::chrono::steady_clock::now().time_since_epoch();
        -:  236:  }
        -:  237:  else
        -:  238:  {
        -:  239:    // this is not the first time we set this entry, we need to check
        -:  240:    // if the type is the same or not.
        -:  241:    Entry& entry = *it->second;
        -:  242:    std::scoped_lock scoped_lock(entry.entry_mutex);
        -:  243:
        -:  244:    Any& previous_any = entry.value;
        -:  245:    Any new_value(value);
        -:  246:
        -:  247:    // special case: entry exists but it is not strongly typed... yet
        -:  248:    if(!entry.info.isStronglyTyped())
        -:  249:    {
        -:  250:      // Use the new type to create a new entry that is strongly typed.
        -:  251:      entry.info = TypeInfo::Create<T>();
        -:  252:      entry.sequence_id++;
        -:  253:      entry.stamp = std::chrono::steady_clock::now().time_since_epoch();
        -:  254:      previous_any = std::move(new_value);
        -:  255:      return;
        -:  256:    }
        -:  257:
        -:  258:    std::type_index previous_type = entry.info.type();
        -:  259:
        -:  260:    // check type mismatch
        -:  261:    if(previous_type != std::type_index(typeid(T)) && previous_type != new_value.type())
        -:  262:    {
        -:  263:      bool mismatching = true;
        -:  264:      if(std::is_constructible<StringView, T>::value)
        -:  265:      {
        -:  266:        Any any_from_string = entry.info.parseString(value);
        -:  267:        if(any_from_string.empty() == false)
        -:  268:        {
        -:  269:          mismatching = false;
        -:  270:          new_value = std::move(any_from_string);
        -:  271:        }
        -:  272:      }
        -:  273:      // check if we are doing a safe cast between numbers
        -:  274:      // for instance, it is safe to use int(100) to set
        -:  275:      // a uint8_t port, but not int(-42) or int(300)
        -:  276:      if constexpr(std::is_arithmetic_v<T>)
        -:  277:      {
        -:  278:        if(mismatching && isCastingSafe(previous_type, value))
        -:  279:        {
        -:  280:          mismatching = false;
        -:  281:        }
        -:  282:      }
        -:  283:
        -:  284:      if(mismatching)
        -:  285:      {
        -:  286:        debugMessage();
        -:  287:
        -:  288:        auto msg = StrCat("Blackboard::set(", key,
        -:  289:                          "): once declared, "
        -:  290:                          "the type of a port shall not change. "
        -:  291:                          "Previously declared type [",
        -:  292:                          BT::demangle(previous_type), "], current type [",
        -:  293:                          BT::demangle(typeid(T)), "]");
        -:  294:        throw LogicError(msg);
        -:  295:      }
        -:  296:    }
        -:  297:    // if doing set<BT::Any>, skip type check
        -:  298:    if constexpr(std::is_same_v<Any, T>)
        -:  299:    {
        -:  300:      previous_any = new_value;
        -:  301:    }
        -:  302:    else
        -:  303:    {
        -:  304:      // copy only if the type is compatible
        -:  305:      new_value.copyInto(previous_any);
        -:  306:    }
        -:  307:    entry.sequence_id++;
        -:  308:    entry.stamp = std::chrono::steady_clock::now().time_since_epoch();
        -:  309:  }
        -:  310:}
        -:  311:
        -:  312:template <typename T>
        -:  313:inline bool Blackboard::get(const std::string& key, T& value) const
        -:  314:{
        -:  315:  if(auto any_ref = getAnyLocked(key))
        -:  316:  {
        -:  317:    if(any_ref.get()->empty())
        -:  318:    {
        -:  319:      return false;
        -:  320:    }
        -:  321:    value = any_ref.get()->cast<T>();
        -:  322:    return true;
        -:  323:  }
        -:  324:  return false;
        -:  325:}
        -:  326:
        -:  327:template <typename T>
        -:  328:inline Expected<Timestamp> Blackboard::getStamped(const std::string& key, T& value) const
        -:  329:{
        -:  330:  if(auto entry = getEntry(key))
        -:  331:  {
        -:  332:    std::unique_lock lk(entry->entry_mutex);
        -:  333:    if(entry->value.empty())
        -:  334:    {
        -:  335:      return nonstd::make_unexpected(StrCat("Blackboard::getStamped() error. Entry [",
        -:  336:                                            key, "] hasn't been initialized, yet"));
        -:  337:    }
        -:  338:    value = entry->value.cast<T>();
        -:  339:    return Timestamp{ entry->sequence_id, entry->stamp };
        -:  340:  }
        -:  341:  return nonstd::make_unexpected(
        -:  342:      StrCat("Blackboard::getStamped() error. Missing key [", key, "]"));
        -:  343:}
        -:  344:
        -:  345:template <typename T>
        -:  346:inline Expected<StampedValue<T>> Blackboard::getStamped(const std::string& key) const
        -:  347:{
        -:  348:  StampedValue<T> out;
        -:  349:  if(auto res = getStamped<T>(key, out.value))
        -:  350:  {
        -:  351:    out.stamp = *res;
        -:  352:    return out;
        -:  353:  }
        -:  354:  else
        -:  355:  {
        -:  356:    return nonstd::make_unexpected(res.error());
        -:  357:  }
        -:  358:}
        -:  359:
        -:  360:}  // namespace BT
