        -:    0:Source:/home/angel/projectMinor/Bullet_Bravo/code/external/Engine-Bravo/code/external/BehaviorTree/include/behaviortree_cpp/utils/locked_reference.hpp
        -:    0:Graph:build/external/BehaviorTree/CMakeFiles/behaviortree_cpp.dir/src/blackboard.cpp.gcno
        -:    0:Data:build/external/BehaviorTree/CMakeFiles/behaviortree_cpp.dir/src/blackboard.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:
        -:    3:#include <mutex>
        -:    4:#include "behaviortree_cpp/utils/safe_any.hpp"
        -:    5:
        -:    6:namespace BT
        -:    7:{
        -:    8:/**
        -:    9: * @brief The LockedPtr class is used to share a pointer to an object
        -:   10: * and a mutex that protects the read/write access to that object.
        -:   11: *
        -:   12: * As long as the object remains in scope, the mutex is locked, therefore
        -:   13: * you must destroy this instance as soon as the pointer was used.
        -:   14: */
        -:   15:template <typename T>
        -:   16:class LockedPtr
        -:   17:{
        -:   18:public:
function BT::LockedPtr<BT::Any>::LockedPtr() called 0 returned 0% blocks executed 0%
    #####:   19:  LockedPtr() = default;
        -:   20:
function BT::LockedPtr<BT::Any>::LockedPtr(BT::Any*, std::mutex*) called 0 returned 0% blocks executed 0%
    #####:   21:  LockedPtr(T* obj, std::mutex* obj_mutex) : ref_(obj), mutex_(obj_mutex)
        -:   22:  {
    #####:   23:    mutex_->lock();
    %%%%%:   23-block  0
call    0 never executed
    #####:   24:  }
        -:   25:
function BT::LockedPtr<BT::Any>::~LockedPtr() called 0 returned 0% blocks executed 0%
    #####:   26:  ~LockedPtr()
        -:   27:  {
    #####:   28:    if(mutex_)
    %%%%%:   28-block  0
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   29:    {
    #####:   30:      mutex_->unlock();
    %%%%%:   30-block  0
call    0 never executed
        -:   31:    }
    #####:   32:  }
        -:   33:
        -:   34:  LockedPtr(LockedPtr const&) = delete;
        -:   35:  LockedPtr& operator=(LockedPtr const&) = delete;
        -:   36:
        -:   37:  LockedPtr(LockedPtr&& other)
        -:   38:  {
        -:   39:    std::swap(ref_, other.ref_);
        -:   40:    std::swap(mutex_, other.mutex_);
        -:   41:  }
        -:   42:
        -:   43:  LockedPtr& operator=(LockedPtr&& other)
        -:   44:  {
        -:   45:    std::swap(ref_, other.ref_);
        -:   46:    std::swap(mutex_, other.mutex_);
        -:   47:  }
        -:   48:
function BT::LockedPtr<BT::Any>::operator bool() const called 0 returned 0% blocks executed 0%
    #####:   49:  operator bool() const
        -:   50:  {
    #####:   51:    return ref_ != nullptr;
    %%%%%:   51-block  0
        -:   52:  }
        -:   53:
        -:   54:  void lock()
        -:   55:  {
        -:   56:    if(mutex_)
        -:   57:    {
        -:   58:      mutex_->lock();
        -:   59:    }
        -:   60:  }
        -:   61:
        -:   62:  void unlock()
        -:   63:  {
        -:   64:    if(mutex_)
        -:   65:    {
        -:   66:      mutex_->unlock();
        -:   67:    }
        -:   68:  }
        -:   69:
function BT::LockedPtr<BT::Any>::get() const called 0 returned 0% blocks executed 0%
    #####:   70:  const T* get() const
        -:   71:  {
    #####:   72:    return ref_;
    %%%%%:   72-block  0
        -:   73:  }
        -:   74:
        -:   75:  const T* operator->() const
        -:   76:  {
        -:   77:    return ref_;
        -:   78:  }
        -:   79:
        -:   80:  T* operator->()
        -:   81:  {
        -:   82:    return ref_;
        -:   83:  }
        -:   84:
        -:   85:  template <typename OtherT>
        -:   86:  void assign(const OtherT& other)
        -:   87:  {
        -:   88:    if(ref_ == nullptr)
        -:   89:    {
        -:   90:      throw std::runtime_error("Empty LockedPtr reference");
        -:   91:    }
        -:   92:    else if constexpr(std::is_same_v<T, OtherT>)
        -:   93:    {
        -:   94:      *ref_ = other;
        -:   95:    }
        -:   96:    else if constexpr(std::is_same_v<BT::Any, OtherT>)
        -:   97:    {
        -:   98:      other->copyInto(*ref_);
        -:   99:    }
        -:  100:    else
        -:  101:    {
        -:  102:      *ref_ = T(other);
        -:  103:    }
        -:  104:  }
        -:  105:
        -:  106:private:
        -:  107:  T* ref_ = nullptr;
        -:  108:  std::mutex* mutex_ = nullptr;
        -:  109:};
        -:  110:
        -:  111:}  // namespace BT
