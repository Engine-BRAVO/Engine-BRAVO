@startuml

' skinparam linetype ortho
skinparam groupInheritance 2
skinparam backgroundColor #AAAAAA

package Components{

class Component{
    - mActive : bool

}

class Sprite{
    + Sprite(Texture* aTexture, int aWidth, int aHeight, Rect aSourceRect = Rect())
    + ~Sprite()

    + Texture* getTexture()

    + getRelativePosition() : Transform 
    + setRelativePosition(Transform aNewTransform) : void 

    + getSource() : Rect 
    + setSource(Rect aSourceRect) : void

    +  setFlipX(bool state) { mFlipX = state; } : void
    +  getFlipX() { return mFlipX; } : bool

    +  setFlipY(bool state) { mFlipY = state; } : void
    +  getFlipY() { return mFlipY; } : bool

    +  setWidth(int aWidth) { mWidth = aWidth; } : void
    +  getWidth() { return mWidth; } : int

    +  setHeight(int aHeight) { mHeight = aHeight; } : void
    +  getHeight() { return mHeight; } : int

    - Texture* mTexture = nullptr;
    - Transform mTransform;

    - Rect mSourceRect;

    - std::string mSprite;
    - int mWidth = 0;
    - int mHeight = 0;
    - bool mFlipX;
    - bool mFlipY;

    - int mLayer;
}

class Animation{
    + Animation(std::vector<Sprite*> aAnimationFrames, int aTimeBetweenFrames, bool aIsLooping = false)
    + ~Animation()

    + getTransform() : Transform 
    + setTransform(Transform aNewTransform) : void 

    + getFrame(int aFrameIndex) : Sprite* 
    + getFrameAtTime(long aTime) : Sprite* 

    + getTimeBetweenFrames() : int 
    + setTimeBetweenFrames(int aTimeBetweenFrames) : void 

    + setFlipX(bool state) : void 
    + getFlipX() : bool 

    + setFlipY(bool state) : void 
    + getFlipY() : bool 

    + isLooping() : bool 
    + setIsLooping(bool aIsLooping) : void 

    + getFrameCount() : int 

    - mTransform : Transform 

    - mFlipX : bool 
    - mFlipY : bool 

    - mAnimationFrames : std::vector<Sprite*> 
    - mTimeBetweenFrames : int 
    - mIsLooping : bool 
}

class AudioSource{
    + void play(??? aLooping)
    + void stop()

    - mAudioClip : string
    - mPlayOnAwake : bool
    - mLoop : bool
    - mVolume : ???
}

class Collider{
    + Collider(point pos, point size)
    + setBodyId() : b2BodyId
    + getBodyId() : b2BodyId
    + getPosition() : point

    ' Relative to position of GameObject
    - mPosition : Point 
    - mBodyId : b2Body

    
}

class CircleColider{
    + CircleCollider(point pos, point size)
    + setBodyId() : b2BodyId
    + getBodyId() : b2BodyId

    ' Position is middle of circle
    - mRadius : float 
}

class BoxCollider{
    + BoxCollider(point pos, point size)
    + setBodyId() : b2BodyId
    + getBodyId() : b2BodyId

    ' Position is middle of box
    - mSize : point
    - mRotation : float
}

enum BodyType{
    STATIC
    DYNAMIC
}

class RigidBody{
    + RigidBody(flag, properties)
    + setMass(float aMass) : void
    + getMass() : float
    + setBodyType(BodyType aBodyType) : void
    + getBodyType() : BodyType
    + setGravityScale(float aGravityScale) : void
    + getGravity() : float
    + getBodyId() : int

    + applyForce(point) : void

    ' SETTERS AND GETTERS FOR MEMBERS
    - mIsUpdated : bool
    - mHasGravity : bool
    - mIsMoveableByForce : bool
    - mCanRotate : bool

    - mBodyType : Enum 

    - mDensity : float
    - mFriction : float
    - mRestitution : float

    - mMass : float
    - mGravityScale : float

    - mBodyId : int

    - mForcesBuffer : vector<point>
}

interface IBehavourScript{
    + {abstract} void onStart()
    + {abstract} void onUpdate()
}

}

class GameObject{
    + addComponent(Component* aComponent) : void
    + isActiveInWorld() : bool
    + isActiveSelf() : bool
    + setID(int aId) : void
    + getID() : int
    + setName(string aName) : void
    + getName() : string
    + setTag(string aTag) : void
    + getTag() : string
    + setIsActive(bool aIsActive) : void
    + getIsActive() : bool
    + hasComponenent() const : template<typename T> bool
    + getComponent() const : template<typename T> T*
    + addComponent(Args&&... args) : template<typename T, typename... Args> T*

    - mComponents : vector<Component*>
    - mName : string
    - mTag : string
    - mIsActive : bool
    - mLayer : ???
    - mID : int
}

struct Transform{
    - mPosition : Point
    - mRotation : float
    - mScale : Point
 }

package Physics{
class PhysicsEngine {

    + updateReferences(vector<GameObject*>&) : void
    + update() : void
    + setSubStep() : void
    + getSubStep() : int
    + executeCollisionScripts(vector<int>) : void
    + getBody(int bodyID) : GameObject

    - GameObjects : vector<GameObject*>
    - step : float
    - subStep : int

}

class BodyProxy {
    + BodyProxy(GameObject&)
    + defineBodyType() : void
    + getBodyFlags() : struct
    + getBodyProperties() : struct
    + getBodyType() : enum
    + getPosition() : point
    + getSize() : point


    - mPosition : point
    - mSize : point

    - mHasGravity : bool
    - mIsMoveableByForce : bool
    - mCanRotate : bool

    - mBodyType : Enum 

    - mDensity : float
    - mFriction : float
    - mRestitution : float

    - mMass : float
    - mGravityScale : float

}

class World {

    + World(b2Vec2 Gravity)

    + executeWorldStep(float step, int subStep) : void
    + reset() : void

    + createBody(BodyProxy& bodyProxy) : b2BoxId
    + updateBody(b2BodyId bodyID, BodyProxy&) : void
    + applyForce(b2BodyId bodyID, point force): void

    + setPosition(b2BodyId bodyID, point pos) : void
    + setGravity(point gravity) : void

    + getPosition(b2BodyId bodyID) : point
    + getGravity() : point

    + checkContactEvent() : vector<int>

    - mWorldID : b2worldId
}

}

package Save{
class SaveGame {
    - mFileName : string
    - mFields : vector<SaveField>
    - mArrays : vector<SaveArray>
    + SaveGame(const string &aFileName)
    + store() : void
    + remove() : void
    + addField(string aName, string aValue) : void
    + setField(string aName, string aValue) : void
    + getField(string aName) : SaveField&
    + getField(string aName) : string
    + addArray(string aName) : void
    + setArray(string aName, SaveArray value) : void
    + getArray(string aName) : SaveArray&
}

class SaveField {
    - mName : string
    - mValue : string
    + SaveField(string aName)
    + getName() : string
    + setValue(string aValue) : void
    + getValue() : string
}

class SaveArray {
    - mName : string
    - mFields : vector<SaveField>
    + SaveArray(string aName)
    + getName() : string
    + addField(string aName, string aValue) : void
    + setField(string aName, string aValue) : void
    + getField(string aName) : string
}
}

class Scene {
    + addGameObject(GameObject* aObject) : void
    + removeGameObject(int aId) : void
    + getGameObject(int aId) : GameObject&
    + addCamera() : int
    + removeCamera(int id) : void
    + getCamera(int id) : Camera&
    + setActiveCamera(int id) : void
    + getID() : int
    + getName() : string
    + getGameObjects() : vector<GameObject*>& 

    - Scene(string aSceneName, int aSceneID)
    - mSceneName : string
    - mGameObjects : vector<GameObject*>
    - mSceneID = -1 : int
    - activeCameraIndex : int
    - cameras : vector<Camera>(1)
}

package Engine{

class EngineBravo {
    + initialize() : void
    + run() : void
    + getSceneManager() : SceneManager&
    + runBehaviourScripts() : void

    - mSaveGameManager : SaveGameManager 
    - mSceneManager : SceneManager
    - mResourceManager : ResourceManager
    - mUIManager : UIManager
    - mRenderer : Renderer
}

class ResourceManager {
    - ResourceManager()
    + loadTextures() : void
    + loadAudio() : void
    + loadTileset(const string &aPath) : Texture*
}

class SceneManager {
    + addScene(const Scene& scene) : int
    + addSceneLevel(TileMap& map) : int
    + loadScene(int index) : void
    + loadScene(const std::string& sceneName) : void
    + getCurrentScene() : Scene*
    + createScene(std::string aSceneName, int aSceneID = -1) : Scene*
    - SceneManager()
    - sceneNameExists(string aSceneName) : bool
    - sceneIDExists(int aSceneID) : bool
    - getNewSceneID() : int
    - mScenes : vector<unique_ptr<Scene>>
    - mCurrentSceneIndex : int
}

class SaveGameManager {
    - SaveGameManager()
    + createSaveGame(const string &aId, const string &aPath) : SaveGame&
    + getSaveGame(const string &aId) : SaveGame&
    + deleteSaveGame(const string &aId, bool aDeleteFile) : void
    - mSaveGames : vector<SaveGame> 
}


class UIManager {
    - mClickableButtons : vector<UIObject&>
    + ClickableButtonPressed() : bool
    + checkIsClickableButton() : bool
    + addClickableButton((UIObject& aButton)) : void
    + removeClickableButton(std::string ID) : void
    - UIManager()
}

class NetworkManager {
    
    
    + void startServer()
    + void startClient()
    + void startHost()
    + void shutdown()


    - mIsServer : bool
    - mIsClient : bool
    - mIsHost : bool
    - mConnectedClients : List<NetworkClient>
    - mTickRate : int
    - mDefaultPlayerPrefab : GameObject&
    - mEnableSceneManagement : bool
}

class PhysicsManager {
    + PhysicsManager()

    + startPhysicsEngine() : void
}

class RenderSystem{
    + RenderSystem()

    + render(Scene* aScene) : void 

    + getRenderer() : Renderer& 
    + getWindow() : Window& 

    - renderSprite(GameObject* aGameObject, Sprite* aSprite) : void 
    - renderAnimation(GameObject* aGameObject, Animation* aAnimation) : void 

    - mRenderer : std::unique_ptr<Renderer> 
    - mWindow : std::unique_ptr<Window> 

    - WindowWidth : int 
    - WindowHeight : int 

    - mBackgroundColor : Color 
}

class Window {
    + Window(int aWindowWidth, int aWindowHeight)
    + ~Window()

    + getSize() : Vector2 

    + setFullScreen() : void 
    + setFloating() : void 
    + toggleFullFloating() : void 

    + getSDLWindow() : SDL_Window* 

    - mWindow = nullptr : SDL_Window* 
}

class Renderer {
    + Renderer(Window& window)
    + ~Renderer() 

    + clear(Color aColor) : void 
    + show() : void 

    + renderTexture(Texture& aTexture, Rect aSourceRect, Vector2 aLocation, int aWidth, int aHeight, bool aFlipX,
                       bool aFlipY, float aRotation) : void

    + renderSquare(Vector2 aLocation, int aWidth, int aHeight, Color aColor, bool aFill) : void 

    + getSDLRenderer() : SDL_Renderer*& 

    - mRenderer = nullptr : SDL_Renderer* 

}
}


class Camera{
    - mBackgroundColor : Color
    ' Width and Height are rendered area in Game Units
    - mWidth : int
    - mHeight : int

}

class Texture {
    + Texture(SDL_Texture* aTexture)
    + ~Texture()

    + SDL_Texture* getSDLTexture();

    - SDL_Texture* mTexture = nullptr;

    - bool mTextureLoaded = false;
}


class TileMap {
    + loadMap(const string& aPath): bool
    + getWidth(): int
    + getHeight(): int
    + getTileWidth(): int
    + getTileHeight(): int
    + getTileLayers(): std::vector<tmx::TileLayer>
    + getObjects(): std::vector<tmx::Object>
    + getTilesets(): std::vector<tmx::Tileset>

    - mMap : tmx::Map
    - mTilesets : std::vector<tmx::Tileset>
    - mTileLayers : std::vector<tmx::TileLayer>
    - mObjects : std::vector<tmx::Object>
}

package UI{
class UIObject{
    - mWidth : int
    - mHeight : int
}

class Button{
    - mInteractable : bool
    - mOnClick : ???
}

class Text{
    - mText : string
    - mFont : ???
    - mSize : ???
    - mAllignment : ???
    - mColor : ???
}
}

package Input{
class iMouseListener{
    + ??? onMouseMoved()
    + ??? onMouseClicked()
    + ??? onMousePressed()
    + ??? onMouseReleased()
}

class iKeyListener{
    + ??? onKeyPressed()
    + ??? onKeyReleased()
}
}

package global{
class Input{}

class Time{}

class Debug{}

' struct Point{
'     - x : float
'     - y : float
' }

class Color{
    - r : int
    - g : int
    - b : int
    - a : int
}

class FSConverter {
    + FSConverter(string) : FSConverter
    + getResourcePath(const std::string& resourceName) : string
    - findResourcesFolder() : string
    - executablePath() : string
    - resourceDir : string
}
}

package Networking{
class NetworkObject {
    + spawn() : void
    + despawn() : void
    + getNetworkID(): int

    - mIsOwner: bool
    - mNetworkID: int
}

interface INetworkBehaviour {
    + {abstract} void serverRpc()
    + {abstract} void clientRpc()
    + {abstract} void OnNetworkSpawn()
    
}

' Template class for network variables
class NetworkVariable{
    + networkVariable(WritePermission)
    + T Value
    
}

class IBehavourScript_Proxy{}

' Maybe not needed
class NetworkTransform {
    + UpdateTransform()
    + SyncPosition()
    + Interpolate()
}

class Transform_Proxy{}

class NetworkClient {
    + ConnectToServer()
    + SendGameState()
    + ReceiveGameState()

    - mIsConnected: bool
    - mClientID: int
}

class NetworkServer {
    + HandleClientConnection()
    + ReceiveGameState()
    + SendGameState()
}

class NetworkHost {
    + ActAsClient()
    + ActAsServer()
}

' class NetworkMessage {
'     + Serialize()
'     + Deserialize()
'     + SendMessage()
'     - mMessageType: string
' }

class NetworkSceneManager {
    + LoadScene()
    + SyncScene()
    + UnloadScene()
}

' class NetworkInputManager {
'     + CaptureInput()
'     + SendInput()
'     + ApplyInputPrediction()
' }

' class NetworkReplicationManager {
'     + ReplicateObjectState()
'     + SyncWithClients()
'     + ApplyInterpolation()
' }

' class AuthorityManager {
'     + AssignAuthority()
'     + RequestControl()
'     - mObjectAuthority: string
' }

class INetworkSerializable {
    + {abstract} NetworkSerialize()
    ' + Deserialize()
}

class Component_Proxy{
}

' NetworkManager <-- AuthorityManager

NetworkObject *-- "*" INetworkBehaviour
NetworkObject -- NetworkTransform
NetworkObject --|> Component_Proxy

INetworkBehaviour --|> IBehavourScript_Proxy
INetworkBehaviour <-- NetworkVariable
INetworkBehaviour <-- INetworkSerializable

NetworkTransform --|> Transform_Proxy

' NetworkClient --> NetworkInputManager
' NetworkClient --> NetworkMessage
' NetworkClient --> NetworkReplicationManager

' NetworkServer --> NetworkMessage
' NetworkServer --> NetworkReplicationManager


NetworkHost <-- NetworkServer
NetworkHost <-- NetworkClient

' AuthorityManager <-- NetworkObject
NetworkSceneManager *-- "*" NetworkObject
}

Component <|-down- AudioSource
Component <|-down- Collider
Component <|-down- RigidBody
Component <|-down- IBehavourScript
Component <|-down- Sprite
Component <|-down- Animation

Collider <|-- CircleColider
Collider <|-- BoxCollider

GameObject *-up- "0..*" AudioSource
GameObject *-up- "0..*" CircleColider
GameObject *-up- "0..*" BoxCollider
GameObject *-up- "0..*" RigidBody
GameObject *-up- "0..*" IBehavourScript
GameObject *-up- "0..*" Sprite
GameObject *-up- "1" Transform
GameObject "0..1"<-- "0..*" GameObject : +parent >

GameObject <|-- UIObject
UIObject <|-- Button
UIObject <|-- Text

Scene *-- "0..*" GameObject
Camera --|> GameObject
Camera "1..*" --*  Scene



SaveGameManager *-- "*" SaveGame
SaveGame *-- "*" SaveField
SaveGame *-- "*" SaveArray
SaveArray *-- "*" SaveField
SceneManager *-- "*" Scene
UIManager o-- "*" UIObject

NetworkManager *-- "0..1"NetworkClient
NetworkManager *-- "0..1"NetworkServer
NetworkManager *-- "0..1"NetworkHost
NetworkManager *-- NetworkSceneManager
NetworkManager *-- "1" NetworkObject
GameObject *-- "0..*" NetworkObject

SceneManager --> TileMap

EngineBravo *-- "1" SceneManager : creates
EngineBravo *-- "1" SaveGameManager : creates
EngineBravo *-- "1" UIManager : creates
EngineBravo *-- "1" ResourceManager : creates
EngineBravo *-- "0..1" NetworkManager 
EngineBravo *-- "1" PhysicsManager : creates
EngineBravo *-- "1" RenderSystem : creates

PhysicsManager *-- "1" PhysicsEngine

PhysicsEngine *-- "1" World
BodyProxy -left-> PhysicsEngine

RenderSystem *-- "1" Renderer
RenderSystem *-- "1" Window

Animation  *-- "2..*" Sprite
Sprite *-- "1" Texture


@enduml
