\documentclass{article}
\usepackage{enumitem}
\usepackage{graphicx}
\graphicspath{ {./images/} }

\title{Engine Bravo Design}
\author{Sean Groenenboom \and Seger Sars \and Siem Vermeulen \and Angel Villanueva \and Ronan Vlak} % Sets authors name
\date{\today}

\begin{document}

\maketitle % Generates the title
\newpage

\tableofcontents
\newpage

\section{Abbreviations}
% Please make sure to keep this in alphabetical order!
\begin{tabular}{c|c}
  \textbf{Abbreviation} & \textbf{Full from} \\ \hline
  API & Application programming interface \\ \hline
  SDL & Simple DirectMedia Layer \\ \hline
  Hz & hertz \\ \hline
  Sfx & Sound effect(s) \\ \hline
  UI & User interface \\
\end{tabular}

\section{Architecture}
The game engine is a singleton. This will be the only singleton in the engine.

Managers contain only references to the game objects which are relevant to them. For example, the physics manager only contains references to game objects with collider or rigidbody components.
Whenever a component is added to or removed from a game object, the game object calls a function in the game engine class. This adds the game object to an update queue. This update queue is used every cycle, where the engine checks all components of the object in the queue, and adds or removes them to the relevant managers.
\textbf{\textit{Motivate why we made this choice!}}

\section{Physics Update}
Physics are updated sequentially in the normal game loop. It is checked how much time has accumulated since the last cycle, and the physics are ticked the required amount of times to keep up with the accumulated time.

\subsection{Alternatives Considered}
\begin{itemize}
  \item Updating physics using a deltatime. This is undesirable, because when the update frequency of the game drops, the physics will also slow down and become unreliable and prone to error.
  \item Multithreading. Not done because rendering can then copy old data and new data in a single frame. Alternative would be copying the data to physics and copying it back when physics is finished, but that would mean copying too much data back and forth per cycle.
\end{itemize}

\section{Level Manager}
The \texttt{levelManager} (state machine responsible for transitioning between scenes) is never automatically updated, it is only updated when called by a behavior script.

\section{Physics Object Types (in Box2D)}
\begin{itemize}
  \item \textbf{Staticbody}: objects which can be manually moved, but are not affected by gravity, mass, etc.
  \item \textbf{Kinematic body}: has zero mass, and can be moved by applying forces to it. It is not affected by gravity.
  \item \textbf{Dynamic body}: has mass, and is affected by gravity and other forces. It can be moved by applying forces to it.
\end{itemize}

\noindent
\textbf{Usage:}
\begin{itemize}
  \item \textbf{Staticbody} is used for walls, and objects which may move but only when explicitly told to do so.
  \item \textbf{Kinematic bodies} are not used, because the gravity of a dynamic body can instead be manually set to zero.
  \item \textbf{Dynamic bodies} are used for all objects which are affected by gravity and/or other forces.
\end{itemize}

\section{GameObjects}
GameObjects should only contain an animator \textit{or} a sprite, not both. The renderer first checks if there is an animator present, and if not, it checks for a sprite.

\section{Controller Input}
Controller input is supported, but not analog values. This is because it does not integrate well with SDL inputs.

\section{UI}
\begin{itemize}
  \item \textbf{Three component types:} text, button, and image.
  \item \textbf{Text rendering:} font, text content, color, and transparency are adjustable.
  \item \textbf{Button:} has an interactable flag and an onclick callback.
  \item \textbf{Image:} has a sprite and a transparency value.
\end{itemize}

\noindent
There is a separate UI manager, which is responsible for checking where the clicks are, checking if the click was on a button, and calling the onclick callback if it was.

\section{Audio}
The audio system is is responsible for playing sfx and music.
\begin{itemize}
  \item Sfx work in a 'fire and forget' way: a single function call to the AudioSource is required to start playing the sound, and it never needs to be stopped or cleaned up in any way. The engine stops playing the sfx when it is finished \footnote{Unless specified that the sound should loop}.
  \item Music can be played, stopped and adjusted while it is playing, however, just like sfc, music does not need to be manually stopped.
\end{itemize}

\subsection{Audio library}
As discussed in the research, it is best to use an audio library (rather than manually doing system calls)
, and there are many audio libraries to choose from. By trying out various audio libraries, it was concluded that
SDL Mixer is the best library to use for this engine. While it is not as extensive as other libraries,
it has the features to meet the engine requirements, and its ease of use makes it a sensible choice.

\subsection{Class diagram}
\includegraphics[width=\textwidth]{audio_class.png}
In the following subsections, the classes in this diagram are further detailed.
\subsubsection{AudioSource}
The AudioSource is a class required by the project's API, it is one of the child classes of Component.
It will therefore be owned by a GameObject, and represent either a single sfx or song.

Things to note about the AudioSource:
\begin{itemize}
  \item When creating an AudioSource, it must be explicitly stated if it is music or an sfx. This is because the AudioManager treats these differently.
  \item mPlayOnWake (required by API) indicates whether the audio source should be played when a new scene is loaded. When this is false, the audio only plays when play() is called.
  \item The x direction and velocity represent the location of the sound in the game, from left to right (x-axis).\footnote{Because the engine is made for 2D games, there is no depth (z-axis) members. Adding verticallity (y-axis) to sound is complex, and out of the scope of this project.} \footnote{The x coordinates and velocity are unrelated to the coordinate system for the game objects.}
\end{itemize}

\subsubsection{AudioManager}
The AudioManager is, similarly to the other manager classes, responsible for controlling all of the sound features in the engine.
It contains only a few basic methods, and delegates most functionality to the audio facade and audio resource manager.

\begin{itemize}
  \item The wake method is used to indicate when a new scene is loaded. This is used to play all the AudioSources set to play on wake.
  \item The mGameObjects contains references to all GameObjects which own an AudioSource. Each cycle, this list is updated by the EngineBravo (which owns the AudioManager), by calling addSound and removeSound. This way, the AudioManager does not have to manually check which objects do and do not own an audio source.
\end{itemize}

\subsubsection{AudioResourceManager}

\subsubsection{IAudioFacade}

\subsubsection{MixerFacade}
note left of MixerFacade
    mLastUsedChannel is used to keep track of the last channel used
end note

\subsubsection{MixerContainer}
note left of MixerContainer
    The string key in mSfx is the path to the sound effect
end note

\section{Transform}
Does not need an update flag when the position is changed, as a movable object is usually moving.

\section{Collider}
Has \texttt{bodyID}, which is needed for the physics.

\section{RigidBody}
Has \texttt{bodyID}, which is needed for the physics.

\section{PhysicsEngine}{
  \begin{itemize}
    \item Steps are at 50 Hz
    \item substeps are configurable by the game programmer
    \item update method gets int of the amount of steps it need to set so less data gets copied to the world class
  \end{itemize}
}

\section{Multithreading}
Multithreading is not added to the engine as it lies out of the scope of the project.

\end{document}
